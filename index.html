<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ticket Map - LocateMapper (Filtered)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* --- Base / Layout ------------------------------------------------ */
        html, body { height: 100%; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            min-height: 100vh;          /* allow full height */
            overflow: auto;             /* allow page to scroll */
            background: #fff;
        }

        /* Header is now in normal flow (no toggle) */
        .header {
            background: linear-gradient(135deg, #007cba 0%, #005a8b 100%);
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: relative;         /* normal document flow */
            z-index: 10;
        }
        .header-content { padding: 15px 20px; }
        .header h1 { font-size: 24px; margin-bottom: 10px; }

        .nav-links { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .nav-links a {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            transition: background 0.3s;
            font-weight: 500;
        }
        .nav-links a:hover { background: rgba(255,255,255,0.3); }

        .filter-bar {
            background: rgba(255,255,255,0.15);
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        .filter-group { display: flex; align-items: center; gap: 8px; }
        .filter-group label { font-size: 14px; font-weight: 500; white-space: nowrap; }
        .filter-group select {
            padding: 6px 12px;
            border: none; border-radius: 4px; background: white; color: #333;
            font-size: 14px; cursor: pointer; min-width: 150px;
        }
        .filter-group select:focus { outline: 2px solid #FFC107; }

        .filter-actions { display: flex; gap: 8px; margin-left: auto; }
        .btn-reset, .btn-refresh {
            padding: 6px 16px; background: rgba(255,255,255,0.25);
            border: 1px solid white; color: white; border-radius: 4px;
            cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.3s;
        }
        .btn-reset:hover, .btn-refresh:hover { background: rgba(255,255,255,0.35); }

        .search-container { position: relative; flex-grow: 1; max-width: 400px; }
        .search-input { width: 100%; padding: 6px 12px; border: none; border-radius: 4px; font-size: 14px; }
        .search-input:focus { outline: 2px solid #FFC107; }

        .stats { display: flex; gap: 15px; flex-wrap: wrap; }
        .stat-item { background: rgba(255,255,255,0.15); padding: 8px 15px; border-radius: 4px; font-size: 14px; }
        .stat-value { font-weight: bold; font-size: 18px; }

        /* Map now gets its height from JS (dynamic: viewport - header-height) */
        #map {
            width: 100%;
            min-height: 360px; /* safe initial height before JS sizing */
        }

        .legend {
            background: white; padding: 15px; border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .legend h4 { margin-bottom: 10px; color: #333; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
        .legend-color { width: 20px; height: 20px; margin-right: 10px; border: 2px solid #333; border-radius: 2px; }

        .ticket-popup { font-size: 14px; }
        .ticket-popup h3 { color: #007cba; margin-bottom: 10px; }
        .ticket-popup .field { margin: 5px 0; }
        .ticket-popup .label { font-weight: bold; color: #555; }

        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 20px 40px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 2000;
            font-size: 18px; color: #007cba;
        }

        /* --- Mobile tweaks ------------------------------------------------- */
        @media (max-width: 768px) {
            .header-content { padding: 10px 15px; }
            .header h1 { font-size: 18px; margin-bottom: 8px; }
            .nav-links { gap: 10px; justify-content: center; }
            .nav-links a { padding: 6px 12px; font-size: 13px; white-space: nowrap; }
            .filter-bar { padding: 10px 15px; gap: 10px; }
            .filter-group { flex-direction: column; align-items: flex-start; gap: 4px; width: 100%; }
            .filter-group select { width: 100%; }
            .filter-actions { width: 100%; margin-left: 0; margin-top: 8px; }
            .btn-reset, .btn-refresh { flex: 1; }
            .stats { gap: 8px; width: 100%; justify-content: center; margin-top: 8px; }
            .stat-item { padding: 6px 10px; font-size: 12px; }
            .stat-value { font-size: 16px; }
            .legend { padding: 10px; font-size: 13px; }
            .legend h4 { font-size: 14px; margin-bottom: 8px; }
            .legend-item { margin-bottom: 6px; font-size: 12px; }
            .legend-color { width: 16px; height: 16px; margin-right: 8px; }
            .ticket-popup h3 { font-size: 16px; margin-bottom: 8px; }
            .ticket-popup .field { margin: 4px 0; font-size: 13px; }
            .loading { padding: 15px 25px; font-size: 16px; }
            /* Optional: nudge zoom controls down so they don't overlap your header */
            .leaflet-control-zoom { margin-top: 10px !important; }
        }
        @media (max-width: 480px) {
            .header h1 { font-size: 16px; }
            .nav-links a { padding: 5px 10px; font-size: 12px; }
            .filter-bar { padding: 8px 12px; }
            .filter-group label { font-size: 12px; }
            .filter-group select { font-size: 13px; padding: 5px 10px; }
            .stat-item { padding: 5px 8px; font-size: 11px; }
            .stat-value { font-size: 14px; }
            .legend { max-width: 150px; padding: 8px; }
            .legend h4 { font-size: 13px; }
            .legend-item { font-size: 11px; }
            .ticket-popup { font-size: 12px; }
            .ticket-popup h3 { font-size: 14px; }
        }
    </style>
</head>
<body>
    <!-- Header (NO toggle) -->
    <div class="header" id="header">
        <div class="header-content">
            <h1>üó∫Ô∏è Ticket Map View (Filtered)</h1>
            <div class="nav-links">
                <a href="ticket-creator.html">‚ûï Create New Ticket</a>
                <a href="dashboard.html">üìä Manage Tickets</a>
                <a href="index.html">üó∫Ô∏è Map View (All)</a>
            </div>

            <div class="filter-bar">
                <div class="filter-group">
                    <label for="ticketFilter">üé´ Ticket:</label>
                    <select id="ticketFilter"><option value="">All Tickets</option></select>
                </div>
                <div class="filter-group">
                    <label for="dateFilter">üìÖ Date:</label>
                    <select id="dateFilter"><option value="">All Dates</option></select>
                </div>
                <div class="filter-group">
                    <label for="statusFilter">üè∑Ô∏è Status:</label>
                    <select id="statusFilter">
                        <option value="">All Statuses</option>
                        <option value="Open">Open</option>
                        <option value="In Progress">In Progress</option>
                        <option value="Complete">Complete</option>
                        <option value="Cancelled">Cancelled</option>
                        <option value="On Hold">On Hold</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="lineColorMode">üé® Line Colors:</label>
                    <select id="lineColorMode" onchange="changeLineColorMode()">
                        <option value="utility">Utility Type (Default)</option>
                        <option value="signal">Signal Score</option>
                        <option value="assurance">Assurance Score</option>
                    </select>
                </div>
                <div class="search-container">
                    <input type="text" id="addressSearch" class="search-input" placeholder="üîç Search address or place..." />
                </div>
                <div class="filter-actions">
                    <button class="btn-refresh" onclick="refreshData()">üîÑ Refresh</button>
                    <button class="btn-reset" onclick="resetFilters()">‚Ü©Ô∏è Reset</button>
                </div>
                <div class="stats">
                    <div class="stat-item"><span class="stat-value" id="filteredCount">0</span> Shown</div>
                    <div class="stat-item"><span class="stat-value" id="totalCount">0</span> Total</div>
                </div>
            </div>
        </div>
    </div>

    <div id="map"></div>
    <div id="loading" class="loading" style="display:none;">Loading tickets...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // --- Dynamic map sizing: viewport minus header height -----------------
        function sizeMapToViewport() {
            const header = document.getElementById('header');
            const mapDiv = document.getElementById('map');
            // Prefer visualViewport on mobile to avoid URL bar jumps
            const viewportH = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
            const headerH = header.getBoundingClientRect().height;
            const target = Math.max(240, viewportH - headerH);
            mapDiv.style.height = target + 'px';
            // Invalidate tiles if map already exists
            if (window.map && typeof map.invalidateSize === 'function') {
                map.invalidateSize(false);
            }
        }

        // Recompute height on resize & when header changes size (wraps on mobile)
        window.addEventListener('resize', sizeMapToViewport);
        const headerObserver = new ResizeObserver(sizeMapToViewport);
        headerObserver.observe(document.getElementById('header'));

        // Initial sizing before Leaflet init so container is non-zero
        sizeMapToViewport();

        // --- Leaflet init ----------------------------------------------------
        const map = L.map('map', { maxZoom: 24 }).setView([41.2, -96.1], 7);

        .leaflet-control-zoom {
        margin-top: 120px !important; /* move down */
        margin-left: 12px;            /* tweak horizontal offset */
        }
        
        const satelliteLayer = L.tileLayer(
            'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            { attribution: 'Tiles &copy; Esri', maxZoom: 24, maxNativeZoom: 19 }
        ).addTo(map);
        const labelsLayer = L.tileLayer(
            'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
            { attribution: 'Labels &copy; Esri', maxZoom: 24, maxNativeZoom: 19 }
        ).addTo(map);

        const statusColors = { 'Open':'#FF6B35','In Progress':'#FFC107','Complete':'#28a745','Cancelled':'#6c757d','On Hold':'#17a2b8' };
        const priorityColors = { 'Emergency':'#dc3545','High':'#fd7e14','Normal':'#007cba' };
        const utilityColors = { 'Electric':'#FF0000','Gas':'#FFFF00','Water':'#0000FF','Sewer':'#00FF00','Telecom':'#FF8F28','Cable':'#FF7200','Fiber':'#00FFFF','Unknown':'#808080' };

        function getSignalScoreColor(score){
            if (score >= 95) return '#006400';
            if (score >= 90) return '#228B22';
            if (score >= 85) return '#32CD32';
            if (score >= 80) return '#7CFC00';
            if (score >= 75) return '#ADFF2F';
            if (score >= 70) return '#FFFF00';
            if (score >= 65) return '#FFD700';
            if (score >= 60) return '#FFA500';
            if (score >= 55) return '#FF8C00';
            if (score >= 50) return '#FF6347';
            if (score >= 45) return '#FF4500';
            if (score >= 40) return '#DC143C';
            return '#8B0000';
        }
        function getAssuranceScoreColor(score){
            if (score >= 95) return '#000080';
            if (score >= 90) return '#0000CD';
            if (score >= 85) return '#0000FF';
            if (score >= 80) return '#1E90FF';
            if (score >= 75) return '#00BFFF';
            if (score >= 70) return '#87CEEB';
            if (score >= 65) return '#B0C4DE';
            if (score >= 60) return '#D8BFD8';
            if (score >= 55) return '#DDA0DD';
            if (score >= 50) return '#DA70D6';
            if (score >= 45) return '#BA55D3';
            if (score >= 40) return '#9370DB';
            return '#8B008B';
        }

        // Legends ------------------------------------------------------------
        const legend = L.control({ position: 'bottomright' });
        legend.onAdd = function(){
            const div = L.DomUtil.create('div','legend');
            div.innerHTML = '<h4>Status</h4>';
            for (const [status,color] of Object.entries(statusColors)){
                div.innerHTML += `<div class="legend-item"><div class="legend-color" style="background-color:${color};"></div><span>${status}</span></div>`
            }
            return div;
        };
        legend.addTo(map);

        function updateLegendContent(div){
            if (lineColorMode === 'signal'){
                div.innerHTML = '<h4>Signal Score</h4>'+
                    '<div class="legend-item"><div class="legend-color" style="background: linear-gradient(to right, #8B0000, #FFFF00, #006400); border-width: 3px;"></div><span>Poor ‚Üí Excellent</span></div>'+
                    '<div style="font-size:11px;margin-top:5px;color:#555;">Red (Low) ‚Üí Yellow (Med) ‚Üí Green (High)</div>';
            } else if (lineColorMode === 'assurance'){
                div.innerHTML = '<h4>Assurance Score</h4>'+
                    '<div class="legend-item"><div class="legend-color" style="background: linear-gradient(to right, #8B008B, #87CEEB, #000080); border-width: 3px;"></div><span>Poor ‚Üí Excellent</span></div>'+
                    '<div style="font-size:11px;margin-top:5px;color:#555;">Purple (Low) ‚Üí Blue (Med) ‚Üí Navy (High)</div>';
            } else {
                div.innerHTML = '<h4>Utility Lines</h4>';
                for (const [u,color] of Object.entries(utilityColors)){
                    if (u !== 'Unknown') div.innerHTML += `<div class="legend-item"><div class="legend-color" style="background-color:${color};border-width:3px;"></div><span>${u}</span></div>`;
                }
            }
        }
        const utilityLegend = L.control({ position: 'bottomleft' });
        utilityLegend.onAdd = function(){
            const div = L.DomUtil.create('div','legend');
            div.id = 'utilityLegend';
            updateLegendContent(div);
            return div;
        };
        utilityLegend.addTo(map);

        // Data loading -------------------------------------------------------
        let allTickets = [];
        let ticketLayers = [];
        let lineLayers = [];
        let lineColorMode = 'utility';
        let currentLinesData = {};
        let currentMapView = null;

        async function loadTickets(){
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            try {
                const response = await fetch('https://od011e6rgl.execute-api.us-east-1.amazonaws.com/api/tickets');
                if (!response.ok) throw new Error('HTTP error! status: ' + response.status);
                const data = await response.json();
                if (data.features && data.features.length > 0){
                    allTickets = data.features;
                    populateTicketFilter(data.features);
                    populateDateFilter(data.features);
                    displayTickets(data.features);
                    updateStats(data.features, data.features);
                } else {
                    alert('No tickets found in the system.');
                }
            } catch (err){
                console.error('Error loading tickets:', err);
                alert('Failed to load tickets: ' + err.message);
            } finally { loadingEl.style.display = 'none'; }
        }

        function populateTicketFilter(features){
            const ticketFilter = document.getElementById('ticketFilter');
            const tickets = new Set();
            features.forEach(f => { if (f.properties.ticket_id) tickets.add(f.properties.ticket_id); });
            Array.from(tickets).sort().forEach(ticket => {
                const o = document.createElement('option'); o.value = ticket; o.textContent = ticket; ticketFilter.appendChild(o);
            });
        }

        async function loadTicketLines(ticketId){
            try {
                const r = await fetch(`https://od011e6rgl.execute-api.us-east-1.amazonaws.com/api/tickets/${ticketId}/lines`);
                if (!r.ok) { console.warn(`No lines data for ticket ${ticketId}`); return null; }
                const d = await r.json();
                return d;
            } catch (e){ console.error(`Error loading lines for ${ticketId}:`, e); return null; }
        }

        function displayTicketLines(linesData){
            if (!linesData || !linesData.lines || linesData.lines.length === 0) return;
            linesData.lines.forEach(line => {
                let coordinates = [];
                if (line.geometry){
                    const m = line.geometry.match(/LINESTRING\((.+)\)/);
                    if (m){
                        coordinates = m[1].split(',').map(pair => {
                            const [lon,lat] = pair.trim().split(' ').map(Number);
                            return [lat, lon];
                        });
                    }
                }
                if (coordinates.length >= 2){
                    let color, scoreInfo='';
                    if (lineColorMode === 'signal' && line.average_signal_score != null){
                        color = getSignalScoreColor(line.average_signal_score);
                        scoreInfo = ` (Signal: ${line.average_signal_score.toFixed(1)})`;
                    } else if (lineColorMode === 'assurance' && line.average_assurance_score != null){
                        color = getAssuranceScoreColor(line.average_assurance_score);
                        scoreInfo = ` (Assurance: ${line.average_assurance_score.toFixed(1)})`;
                    } else {
                        color = (line.color_hex && line.color_hex !== '#808080') ? line.color_hex : (utilityColors[line.utility_type] || utilityColors['Unknown']);
                    }
                    const polyline = L.polyline(coordinates, { color, weight: 4, opacity: 0.8 }).addTo(map);
                    const linePopup = `
                        <div class="ticket-popup">
                            <h3>${line.line_name}${scoreInfo}</h3>
                            <div class="field"><span class="label">Type:</span> ${line.utility_type}</div>
                            <div class="field"><span class="label">Length:</span> ${line.length_ft.toFixed(2)} ft</div>
                            <div class="field"><span class="label">Points:</span> ${line.point_count}</div>
                            ${line.average_signal_score != null ? `<div class='field'><span class='label'>Signal Score:</span> <strong style='color:${getSignalScoreColor(line.average_signal_score)}'>${line.average_signal_score.toFixed(1)}</strong></div>` : ''}
                            ${line.average_assurance_score != null ? `<div class='field'><span class='label'>Assurance Score:</span> <strong style='color:${getAssuranceScoreColor(line.average_assurance_score)}'>${line.average_assurance_score.toFixed(1)}</strong></div>` : ''}
                        </div>`;
                    polyline.bindPopup(linePopup);
                    lineLayers.push(polyline);
                }
            });
        }

        function populateDateFilter(features){
            const dates = new Set();
            features.forEach(f => { if (f.properties.due_date){ dates.add(new Date(f.properties.due_date).toLocaleDateString()); } });
            const dateFilter = document.getElementById('dateFilter');
            Array.from(dates).sort((a,b) => new Date(b) - new Date(a)).forEach(date => {
                const o = document.createElement('option'); o.value = date; o.textContent = date; dateFilter.appendChild(o);
            });
        }

        async function displayTickets(features){
            ticketLayers.forEach(l => map.removeLayer(l)); ticketLayers = [];
            lineLayers.forEach(l => map.removeLayer(l)); lineLayers = [];

            for (const feature of features){
                const props = feature.properties;
                const coords = feature.geometry.coordinates[0];
                const latlngs = coords.map(c => [c[1], c[0]]);
                const color = statusColors[props.status] || priorityColors[props.priority] || '#007cba';

                const polygon = L.polygon(latlngs, { color, fillColor: color, fillOpacity: 0.3, weight: 3 }).addTo(map);
                const bounds = polygon.getBounds();
                const center = bounds.getCenter();
                const label = L.marker(center, {
                    icon: L.divIcon({
                        className: 'ticket-label',
                        html: `<div style="background:white;padding:4px 8px;border-radius:4px;border:2px solid ${color};font-weight:bold;color:${color};font-size:12px;white-space:nowrap;box-shadow:0 2px 5px rgba(0,0,0,0.3);">${props.ticket_id}</div>`,
                        iconSize: null
                    })
                }).addTo(map);

                const linesData = await loadTicketLines(props.ticket_id);
                let linesSummary = '';
                if (linesData && linesData.lines && linesData.lines.length > 0){
                    currentLinesData[props.ticket_id] = linesData;
                    displayTicketLines(linesData);
                    const totalLength = linesData.lines.reduce((sum, l) => sum + l.length_ft, 0);
                    linesSummary = `<div class="field"><span class="label">Lines Located:</span> ${linesData.count} (${totalLength.toFixed(0)} ft total)</div>`;
                }

                const popupContent = `
                    <div class='ticket-popup'>
                        <h3>${props.ticket_id}</h3>
                        <div class='field'><span class='label'>Work Type:</span> ${props.work_type || 'N/A'}</div>
                        <div class='field'><span class='label'>Status:</span> ${props.status || 'N/A'}</div>
                        <div class='field'><span class='label'>Priority:</span> ${props.priority || 'N/A'}</div>
                        <div class='field'><span class='label'>Due Date:</span> ${props.due_date ? new Date(props.due_date).toLocaleString() : 'N/A'}</div>
                        <div class='field'><span class='label'>Description:</span> ${props.description || 'N/A'}</div>
                        ${linesSummary}
                    </div>`;

                polygon.bindPopup(popupContent);
                label.bindPopup(popupContent);
                ticketLayers.push(polygon); ticketLayers.push(label);
            }

            if (!currentMapView && features.length > 0){
                const bounds = [];
                features.forEach(f => {
                    if (f.geometry && f.geometry.coordinates && f.geometry.coordinates[0]){
                        f.geometry.coordinates[0].forEach(c => bounds.push([c[1], c[0]]));
                    }
                });
                if (bounds.length > 0){ map.fitBounds(bounds, { padding: [50,50] }); }
            } else if (currentMapView){
                map.setView(currentMapView.center, currentMapView.zoom);
            }
        }

        function updateStats(filtered, all){
            document.getElementById('filteredCount').textContent = filtered.length;
            document.getElementById('totalCount').textContent = all.length;
        }

        function applyFilters(){
            const t = document.getElementById('ticketFilter').value;
            const d = document.getElementById('dateFilter').value;
            const s = document.getElementById('statusFilter').value;
            let filtered = allTickets;
            if (t) filtered = filtered.filter(f => f.properties.ticket_id === t);
            if (d) filtered = filtered.filter(f => f.properties.due_date && new Date(f.properties.due_date).toLocaleDateString() === d);
            if (s) filtered = filtered.filter(f => f.properties.status === s);
            displayTickets(filtered);
            updateStats(filtered, allTickets);
        }

        function resetFilters(){
            document.getElementById('ticketFilter').value = '';
            document.getElementById('dateFilter').value = '';
            document.getElementById('statusFilter').value = '';
            applyFilters();
        }

        async function refreshData(){
            currentMapView = { center: map.getCenter(), zoom: map.getZoom() };
            ticketLayers.forEach(l => map.removeLayer(l)); ticketLayers = [];
            lineLayers.forEach(l => map.removeLayer(l)); lineLayers = [];
            currentLinesData = {};
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            try { await loadTickets(); }
            catch(e){ console.error('Refresh failed:', e); alert('Failed to refresh data. Please try again.'); }
            finally { loading.style.display = 'none'; }
        }

        async function searchAddress(query){
            if (!query || query.trim().length < 3) return;
            try {
                const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=us&addressdetails=1&limit=5`);
                const results = await r.json();
                if (results && results.length > 0){
                    const best = results.reduce((best, cur) => ((+cur.importance || 0) > (+best.importance || 0) ? cur : best));
                    const lat = parseFloat(best.lat), lon = parseFloat(best.lon);
                    currentMapView = { center: [lat, lon], zoom: 19 };
                    map.setView([lat, lon], 19);
                    const m = L.marker([lat, lon]).addTo(map).bindPopup(`<b>${best.display_name}</b>`).openPopup();
                    setTimeout(() => map.removeLayer(m), 10000);
                } else { alert('Location not found. Please try a different search.'); }
            } catch (e){ console.error('Geocoding error:', e); alert('Search failed. Please try again.'); }
        }

        function changeLineColorMode(){
            const select = document.getElementById('lineColorMode');
            lineColorMode = select.value;
            const legendDiv = document.getElementById('utilityLegend');
            if (legendDiv) updateLegendContent(legendDiv);
            lineLayers.forEach(l => map.removeLayer(l)); lineLayers = [];
            for (const ticketId in currentLinesData){ displayTicketLines(currentLinesData[ticketId]); }
        }

        document.getElementById('ticketFilter').addEventListener('change', applyFilters);
        document.getElementById('dateFilter').addEventListener('change', applyFilters);
        document.getElementById('statusFilter').addEventListener('change', applyFilters);
        document.getElementById('addressSearch').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchAddress(e.target.value);
        });

        // Load data after Leaflet is ready and height is set
        window.addEventListener('load', () => {
            sizeMapToViewport();
            loadTickets();
        });
    </script>
</body>
</html>
